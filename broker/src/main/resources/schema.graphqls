scalar Long
scalar JSON

enum DataFormat {
    JSON
    BINARY
}

enum MessageStoreType {
    NONE
    MEMORY
    HAZELCAST
    POSTGRES
    CRATEDB
    MONGODB
    SQLITE
}

enum MessageArchiveType {
    NONE
    POSTGRES
    CRATEDB
    MONGODB
    KAFKA
    SQLITE
}

# Metrics for the broker
type BrokerMetrics {
    # Total messages received from clients on this node
    messagesIn: Long!
    # Total messages sent to clients on this node
    messagesOut: Long!
    # Number of sessions on this node
    nodeSessionCount: Int!
    # Total number of sessions in the cluster
    clusterSessionCount: Int!
    # Total number of queued messages in the cluster
    queuedMessagesCount: Long!
    # Size of the topic index (TopicTree)
    topicIndexSize: Int!
    # Size of the client-to-node mapping
    clientNodeMappingSize: Int!
    # Total size of topic-to-node mapping sets
    topicNodeMappingSize: Int!
    # Messages received from other nodes via message bus
    messageBusIn: Long!
    # Messages sent to other nodes via message bus
    messageBusOut: Long!
    # ISO 8601 timestamp when these metrics were captured (e.g., "2024-01-15T10:30:00Z")
    timestamp: String!
}

# Represents a broker node in the cluster
type Broker {
    # The ID of the node
    nodeId: String!
    # Current metrics for this broker node (single most recent entry)
    metrics: [BrokerMetrics!]!
    # Historical metrics data for this broker node
    metricsHistory(
        # ISO 8601 timestamp for start of time range (e.g., "2024-01-15T10:00:00Z")
        from: String
        # ISO 8601 timestamp for end of time range (e.g., "2024-01-15T11:00:00Z")
        to: String
        # Alternative to from/to: get metrics from the last N minutes
        lastMinutes: Int
    ): [BrokerMetrics!]!
    # Sessions on this broker node with optional filters
    sessions(cleanSession: Boolean, connected: Boolean): [Session!]!
}

# Represents a client session
type Session {
    # The client ID
    clientId: String!
    # The ID of the node this session is connected to
    nodeId: String!
    # Current metrics for this session (single most recent entry)
    metrics: [SessionMetrics!]!
    # Historical metrics data for this session
    metricsHistory(
        # ISO 8601 timestamp for start of time range (e.g., "2024-01-15T10:00:00Z")
        from: String
        # ISO 8601 timestamp for end of time range (e.g., "2024-01-15T11:00:00Z")
        to: String
        # Alternative to from/to: get metrics from the last N minutes
        lastMinutes: Int
    ): [SessionMetrics!]!
    # The subscriptions for this session
    subscriptions: [MqttSubscription!]!
    # Is the session clean
    cleanSession: Boolean!
    # The session expiry interval
    sessionExpiryInterval: Long!
    # The client's address
    clientAddress: String
    # Whether the client is currently connected
    connected: Boolean!
    # Number of queued messages for this session
    queuedMessageCount: Long!
}

# Metrics for a single session
type SessionMetrics {
    # Messages received from this client
    messagesIn: Long!
    # Messages sent to this client
    messagesOut: Long!
    # ISO 8601 timestamp when these metrics were captured (e.g., "2024-01-15T10:30:00Z")
    timestamp: String!
}

# Represents an MQTT subscription
type MqttSubscription {
    # The topic filter
    topicFilter: String!
    # The Quality of Service level
    qos: Int!
}

type Query {
    # Get current value of a topic from LastValueStore
    currentValue(topic: String!, format: DataFormat = JSON, archiveGroup: String = "Default"): TopicValue
    
    # Get current values matching a topic filter
    currentValues(topicFilter: String!, format: DataFormat = JSON, limit: Int = 100, archiveGroup: String = "Default"): [TopicValue!]!
    
    # Get retained message for a specific topic
    retainedMessage(topic: String!, format: DataFormat = JSON): RetainedMessage
    
    # Get all retained messages matching a filter
    retainedMessages(topicFilter: String, format: DataFormat = JSON, limit: Int = 100): [RetainedMessage!]!
    
    # Query historical messages from archive
    archivedMessages(
        topicFilter: String!
        startTime: String
        endTime: String
        format: DataFormat = JSON
        limit: Int = 100
        archiveGroup: String = "Default"
    ): [ArchivedMessage!]!
    
    # Search for topics by name pattern
    searchTopics(
        pattern: String!
        limit: Int = 100
        archiveGroup: String = "Default"
    ): [String!]!
    
    # Get a specific broker by its node ID. If nodeId is omitted, returns the current node.
    broker(nodeId: String): Broker
    # Get all brokers in the cluster
    brokers: [Broker!]!
    # Get active sessions. If nodeId is omitted, returns sessions from all nodes.
    sessions(nodeId: String, cleanSession: Boolean, connected: Boolean): [Session!]!
    # Get a specific session by client ID. If nodeId is omitted, it will be looked up.
    session(clientId: String!, nodeId: String): Session

    # User Management
    users(username: String): [UserInfo!]!

    # ArchiveGroup Management
    archiveGroups: [ArchiveGroupInfo!]!
    archiveGroup(name: String!): ArchiveGroupInfo
}

type Mutation {
    # Authentication (no token required) - returns null when authentication is disabled
    login(username: String!, password: String!): LoginResult
    
    # Publish a message to a topic (requires token + ACL check)
    publish(input: PublishInput!): PublishResult!
    
    # Publish multiple messages (requires token + ACL check)
    publishBatch(inputs: [PublishInput!]!): [PublishResult!]!
    
    # User Management (requires admin token)
    createUser(input: CreateUserInput!): UserManagementResult!
    updateUser(input: UpdateUserInput!): UserManagementResult!
    deleteUser(username: String!): UserManagementResult!
    setPassword(input: SetPasswordInput!): UserManagementResult!
    
    # ACL Rule Management (requires admin token)
    createAclRule(input: CreateAclRuleInput!): UserManagementResult!
    updateAclRule(input: UpdateAclRuleInput!): UserManagementResult!
    deleteAclRule(id: String!): UserManagementResult!

    # Queued Messages Management (requires admin token)
    purgeQueuedMessages(clientId: String): PurgeResult!

    # ArchiveGroup Management (requires admin token)
    createArchiveGroup(input: CreateArchiveGroupInput!): ArchiveGroupResult!
    updateArchiveGroup(input: UpdateArchiveGroupInput!): ArchiveGroupResult!
    deleteArchiveGroup(name: String!): ArchiveGroupResult!
    enableArchiveGroup(name: String!): ArchiveGroupResult!
    disableArchiveGroup(name: String!): ArchiveGroupResult!
}

type Subscription {
    # Subscribe to real-time topic updates
    topicUpdates(topicFilter: String!, format: DataFormat = JSON): TopicUpdate!
    
    # Subscribe to multiple topic filters
    multiTopicUpdates(topicFilters: [String!]!, format: DataFormat = JSON): TopicUpdate!
}

input PublishInput {
    topic: String!
    payload: String!
    format: DataFormat = JSON
    qos: Int = 0
    retained: Boolean = false
}

type PublishResult {
    success: Boolean!
    topic: String!
    timestamp: Long!
    error: String
}

type TopicValue {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
}

type RetainedMessage {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
}

type ArchivedMessage {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
    clientId: String
}

type TopicUpdate {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
    retained: Boolean!
    clientId: String
}

# User Management Types

type UserInfo {
    username: String!
    enabled: Boolean!
    canSubscribe: Boolean!
    canPublish: Boolean!
    isAdmin: Boolean!
    createdAt: String
    updatedAt: String
    aclRules: [AclRuleInfo!]!
}

type AclRuleInfo {
    id: String!
    username: String!
    topicPattern: String!
    canSubscribe: Boolean!
    canPublish: Boolean!
    priority: Int!
    createdAt: String
}

input CreateUserInput {
    username: String!
    password: String!
    enabled: Boolean = true
    canSubscribe: Boolean = true
    canPublish: Boolean = true
    isAdmin: Boolean = false
}

input UpdateUserInput {
    username: String!
    enabled: Boolean
    canSubscribe: Boolean
    canPublish: Boolean
    isAdmin: Boolean
}

input SetPasswordInput {
    username: String!
    password: String!
}

input CreateAclRuleInput {
    username: String!
    topicPattern: String!
    canSubscribe: Boolean = false
    canPublish: Boolean = false
    priority: Int = 0
}

input UpdateAclRuleInput {
    id: String!
    username: String
    topicPattern: String
    canSubscribe: Boolean
    canPublish: Boolean
    priority: Int
}

# ArchiveGroup Management Types

type NodeConnectionStatus {
    nodeId: String!
    # Connection status for different store components
    messageArchive: Boolean
    lastValueStore: Boolean
    # Error message if connection failed
    error: String
    # Timestamp when status was checked
    timestamp: Long!
}

type ArchiveGroupInfo {
    name: String!
    enabled: Boolean!
    deployed: Boolean!
    deploymentId: String
    topicFilter: [String!]!
    retainedOnly: Boolean!
    lastValType: MessageStoreType!
    archiveType: MessageArchiveType!
    lastValRetention: String
    archiveRetention: String
    purgeInterval: String
    createdAt: String
    updatedAt: String
    # Database connection status from all nodes in the cluster
    connectionStatus: [NodeConnectionStatus!]!
}

input CreateArchiveGroupInput {
    name: String!
    topicFilter: [String!]!
    retainedOnly: Boolean = false
    lastValType: MessageStoreType!
    archiveType: MessageArchiveType!
    lastValRetention: String
    archiveRetention: String
    purgeInterval: String
}

input UpdateArchiveGroupInput {
    name: String!
    topicFilter: [String!]
    retainedOnly: Boolean
    lastValType: MessageStoreType
    archiveType: MessageArchiveType
    lastValRetention: String
    archiveRetention: String
    purgeInterval: String
}

type ArchiveGroupResult {
    success: Boolean!
    message: String
    archiveGroup: ArchiveGroupInfo
}

# Authentication Types
type LoginResult {
    success: Boolean!
    token: String
    message: String
    username: String
    isAdmin: Boolean!
}

type UserManagementResult {
    success: Boolean!
    message: String
    user: UserInfo
    aclRule: AclRuleInfo
}

type PurgeResult {
    success: Boolean!
    message: String
    deletedCount: Long!
}

# OPC UA Device Configuration Types

enum OpcUaPublishMode {
    SINGLE
    SEPARATE
}

type OpcUaAddress {
    address: String!
    topic: String!
    publishMode: OpcUaPublishMode!
    removePath: Boolean!
}

type MonitoringParameters {
    bufferSize: Int!
    samplingInterval: Float!
    discardOldest: Boolean!
}

enum SecurityPolicy {
    None
    Basic256Sha256
    Basic256
    Basic128Rsa15
    Aes256_Sha256_RsaPss
    Aes128_Sha256_RsaOaep
}

type OpcUaConnectionConfig {
    endpointUrl: String!
    updateEndpointUrl: Boolean!
    securityPolicy: SecurityPolicy!
    username: String
    subscriptionSamplingInterval: Float!
    keepAliveFailuresAllowed: Int!
    reconnectDelay: Long!
    connectionTimeout: Long!
    requestTimeout: Long!
    monitoringParameters: MonitoringParameters!
    addresses: [OpcUaAddress!]!
}

type OpcUaDevice {
    name: String!
    namespace: String!
    nodeId: String!
    backupNodeId: String
    config: OpcUaConnectionConfig!
    enabled: Boolean!
    createdAt: String!
    updatedAt: String!
    isOnCurrentNode: Boolean!
}

type ClusterNode {
    nodeId: String!
    isCurrent: Boolean!
}

type OpcUaDeviceResult {
    success: Boolean!
    device: OpcUaDevice
    errors: [String!]!
}


input MonitoringParametersInput {
    bufferSize: Int = 100
    samplingInterval: Float = 0.0
    discardOldest: Boolean = false
}

input OpcUaConnectionConfigInput {
    endpointUrl: String!
    updateEndpointUrl: Boolean = true
    securityPolicy: SecurityPolicy = None
    username: String
    password: String
    subscriptionSamplingInterval: Float = 0.0
    keepAliveFailuresAllowed: Int = 3
    reconnectDelay: Long = 5000
    connectionTimeout: Long = 10000
    requestTimeout: Long = 5000
    monitoringParameters: MonitoringParametersInput
}

input OpcUaAddressInput {
    address: String!
    topic: String!
    publishMode: OpcUaPublishMode = SEPARATE
    removePath: Boolean = true
}

input OpcUaDeviceInput {
    name: String!
    namespace: String!
    nodeId: String!
    backupNodeId: String
    config: OpcUaConnectionConfigInput!
    enabled: Boolean = true
}

# Extend existing Query type
extend type Query {
    # Get all OPC UA device configurations
    opcUaDevices: [OpcUaDevice!]!

    # Get a specific OPC UA device configuration by name
    opcUaDevice(name: String!): OpcUaDevice

    # Get OPC UA devices assigned to a specific cluster node
    opcUaDevicesByNode(nodeId: String!): [OpcUaDevice!]!

    # Get list of available cluster nodes
    clusterNodes: [ClusterNode!]!
}

# Extend existing Mutation type
extend type Mutation {
    # Add a new OPC UA device configuration
    addOpcUaDevice(input: OpcUaDeviceInput!): OpcUaDeviceResult!

    # Update an existing OPC UA device configuration
    updateOpcUaDevice(name: String!, input: OpcUaDeviceInput!): OpcUaDeviceResult!

    # Delete an OPC UA device configuration
    deleteOpcUaDevice(name: String!): Boolean!

    # Enable or disable an OPC UA device
    toggleOpcUaDevice(name: String!, enabled: Boolean!): OpcUaDeviceResult!

    # Reassign an OPC UA device to a different cluster node
    reassignOpcUaDevice(name: String!, nodeId: String!): OpcUaDeviceResult!

    # Add an address to an OPC UA device
    addOpcUaAddress(deviceName: String!, input: OpcUaAddressInput!): OpcUaDeviceResult!

    # Delete an address from an OPC UA device
    deleteOpcUaAddress(deviceName: String!, address: String!): OpcUaDeviceResult!
}