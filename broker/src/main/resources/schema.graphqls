scalar Long
scalar JSON

# Data format specification for MQTT message payloads
# Determines how payload data is interpreted and processed by the GraphQL API
enum DataFormat {
    # JSON format: payload is parsed as JSON and returned as structured data
    # Allows for rich querying and manipulation of message content
    # Invalid JSON will result in parsing errors
    JSON
    # Binary format: payload is treated as raw binary data encoded in base64
    # Preserves exact byte content for non-text data (images, files, etc.)
    # Always safe for any payload content regardless of encoding
    BINARY
}

enum MessageStoreType {
    NONE
    MEMORY
    HAZELCAST
    POSTGRES
    CRATEDB
    MONGODB
    SQLITE
}

enum MessageArchiveType {
    NONE
    POSTGRES
    CRATEDB
    MONGODB
    KAFKA
    SQLITE
}

enum PayloadFormat {
    DEFAULT
    JSON
}

# Metrics for the broker
type BrokerMetrics {
    # Messages per second received from clients on this node
    messagesIn: Float!
    # Messages per second sent to clients on this node
    messagesOut: Float!
    # Number of sessions on this node
    nodeSessionCount: Int!
    # Total number of sessions in the cluster
    clusterSessionCount: Int!
    # Total number of queued messages in the cluster
    queuedMessagesCount: Long!
    # Size of the topic index (TopicTree)
    topicIndexSize: Int!
    # Size of the client-to-node mapping
    clientNodeMappingSize: Int!
    # Total size of topic-to-node mapping sets
    topicNodeMappingSize: Int!
    # Messages per second received from other nodes via message bus
    messageBusIn: Float!
    # Messages per second sent to other nodes via message bus
    messageBusOut: Float!
    # Messages per second received via MQTT bridge clients (remote -> local)
    mqttClientIn: Float!
    # Messages per second sent via MQTT bridge clients (local -> remote)
    mqttClientOut: Float!
    # Messages per second received via Kafka bridge clients (Kafka -> MQTT)
    kafkaClientIn: Float!
    # Messages per second published via Kafka bridge clients (MQTT -> Kafka)
    kafkaClientOut: Float!
    # Messages per second received from OPC UA devices (value changes)
    opcUaClientIn: Float!
    # Messages per second sent to OPC UA devices (writes)
    opcUaClientOut: Float!
    # Messages per second received from WinCC OA clients (datapoint value changes)
    winCCOaClientIn: Float!
    # Messages per second received from WinCC Unified clients (tag values and alarms)
    winCCUaClientIn: Float!
    # ISO 8601 timestamp when these metrics were captured (e.g., "2024-01-15T10:30:00Z")
    timestamp: String!
}

# Metrics for an OPC UA device connector
# messagesIn: value changes received from OPC UA server into broker
# messagesOut: values written from broker to OPC UA server
 type OpcUaDeviceMetrics {
     messagesIn: Float!
     messagesOut: Float!
     timestamp: String!
 }
  

# Represents a broker node in the MonsterMQ cluster
# Each broker node runs independently and can handle MQTT clients, message processing, and data storage
type Broker {
    # Unique identifier for this cluster node (used for load balancing and device assignment)
    nodeId: String!
    # MonsterMQ version string (e.g., "1.6.5+9945c5a")
    version: String!
    # Current performance metrics for this broker node (latest snapshot)
    # Returns array with single most recent metrics entry for consistency with metricsHistory
    metrics: [BrokerMetrics!]!
    # Historical performance metrics over a specified time range
    # Useful for monitoring trends, performance analysis, and capacity planning
    metricsHistory(
        # ISO 8601 start timestamp (optional - defaults to 24 hours ago)
        from: String
        # ISO 8601 end timestamp (optional - defaults to now)
        to: String
        # Alternative time range: metrics from the last N minutes (overrides from/to if specified)
        lastMinutes: Int
    ): [BrokerMetrics!]!
    # MQTT client sessions managed by this broker node
    # Sessions persist client state, subscriptions, and queued messages
    sessions(
        # Filter by session persistence type: true=clean, false=persistent, null=all
        cleanSession: Boolean,
        # Filter by connection status: true=active connections, false=disconnected, null=all
        connected: Boolean
    ): [Session!]!
}

# Represents a client session
type Session {
    # The client ID
    clientId: String!
    # The ID of the node this session is connected to
    nodeId: String!
    # Current metrics for this session (single most recent entry)
    metrics: [SessionMetrics!]!
    # Historical metrics data for this session
    metricsHistory(
        # ISO 8601 timestamp for start of time range (e.g., "2024-01-15T10:00:00Z")
        from: String
        # ISO 8601 timestamp for end of time range (e.g., "2024-01-15T11:00:00Z")
        to: String
        # Alternative to from/to: get metrics from the last N minutes
        lastMinutes: Int
    ): [SessionMetrics!]!
    # The subscriptions for this session
    subscriptions: [MqttSubscription!]!
    # Is the session clean
    cleanSession: Boolean!
    # The session expiry interval
    sessionExpiryInterval: Long!
    # The client's address
    clientAddress: String
    # Whether the client is currently connected
    connected: Boolean!
    # Number of queued messages for this session
    queuedMessageCount: Long!
    # Additional session information as JSON
    information: String
}

# Metrics for a single session
type SessionMetrics {
    # Messages per second received from this client
    messagesIn: Float!
    # Messages per second sent to this client
    messagesOut: Float!
    # ISO 8601 timestamp when these metrics were captured (e.g., "2024-01-15T10:30:00Z")
    timestamp: String!
}

# Metrics for a MQTT bridge client
 type MqttClientMetrics {
     # Messages per second received from remote broker (SUBSCRIBE flow)
     messagesIn: Float!
     # Messages per second published to remote broker (PUBLISH flow)
     messagesOut: Float!
     # ISO 8601 timestamp when these metrics were captured
     timestamp: String!
 }

# Metrics for an archive group
type ArchiveGroupMetrics {
    # Messages per second being written to the archive database
    messagesOut: Float!
    # Average buffer size (number of queued messages waiting to be written)
    bufferSize: Int!
    # ISO 8601 timestamp when these metrics were captured
    timestamp: String!
}

# Represents an MQTT subscription
type MqttSubscription {
    # The topic filter
    topicFilter: String!
    # The Quality of Service level
    qos: Int!
}

type Query {
    # Get the most recent value for a specific MQTT topic from the LastValueStore
    # Returns the latest published value with timestamp and QoS information
    # Useful for dashboard displays and current status monitoring
    currentValue(
        # Exact MQTT topic name (no wildcards allowed)
        topic: String!,
        # Data format for the payload: JSON (parsed) or BINARY (base64 encoded)
        format: DataFormat = JSON,
        # ArchiveGroup containing the topic's last value store
        archiveGroup: String = "Default"
    ): TopicValue

    # Get current values for multiple topics matching an MQTT topic filter
    # Supports MQTT wildcards: '+' (single level) and '#' (multi-level)
    # Returns array of most recent values from the LastValueStore
    currentValues(
        # MQTT topic filter with wildcards: "sensor/+/temperature", "device/#", etc.
        topicFilter: String!,
        # Data format for all returned payloads
        format: DataFormat = JSON,
        # Maximum number of topics to return (ordered by topic name)
        limit: Int = 100,
        # ArchiveGroup to search within
        archiveGroup: String = "Default"
    ): [TopicValue!]!

    # Get retained message for a specific MQTT topic from the RetainedMessageStore
    # Retained messages persist until explicitly removed or overwritten
    # Different from currentValue as it only includes messages published with retain=true
    retainedMessage(
        # Exact MQTT topic name
        topic: String!,
        # Data format for the payload
        format: DataFormat = JSON
    ): RetainedMessage

    # Get all retained messages matching an MQTT topic filter
    # Returns messages that were published with the MQTT retain flag
    # Useful for discovering what retained data exists in the system
    retainedMessages(
        # MQTT topic filter with wildcards (optional - null returns all retained messages)
        topicFilter: String,
        # Data format for all payloads
        format: DataFormat = JSON,
        # Maximum number of messages to return
        limit: Int = 100
    ): [RetainedMessage!]!

    # Query historical messages from the message archive
    # Searches through time-series data stored for long-term analysis
    # Returns messages within specified time range and topic filter
    archivedMessages(
        # MQTT topic filter with wildcards to match archived messages
        topicFilter: String!
        # ISO 8601 start timestamp: "2024-01-15T10:00:00Z" (optional - defaults to 24h ago)
        startTime: String
        # ISO 8601 end timestamp: "2024-01-15T11:00:00Z" (optional - defaults to now)
        endTime: String
        # Data format for all payloads
        format: DataFormat = JSON
        # Maximum number of messages to return (ordered by timestamp)
        limit: Int = 100
        # ArchiveGroup containing the message archive to search
        archiveGroup: String = "Default"
    ): [ArchivedMessage!]!
    
    # Search for topics by name pattern using SQL LIKE wildcards
    # Supports '%' (matches any sequence of characters) and '_' (matches single character)
    # Examples:
    #   pattern: "sensor%" → finds all topics starting with "sensor"
    #   pattern: "%temperature%" → finds all topics containing "temperature"
    #   pattern: "device_0_" → finds topics like "device_01", "device_02", etc.
    # Requires an ArchiveGroup to search within its last value store
    searchTopics(
        # SQL LIKE pattern with % and _ wildcards
        pattern: String!
        # Maximum number of topics to return
        limit: Int = 100
        # ArchiveGroup name to search within (each group has its own last value store)
        archiveGroup: String = "Default"
    ): [String!]!

    # Browse topics hierarchically using MQTT-style topic structure
    # Uses MQTT topic conventions: '/' as level separator, '+' for single-level wildcard
    # Returns only direct child topics (one level down) from the specified path
    # Examples:
    #   topic: "opcua" → returns ["opcua/device1", "opcua/device2"] (not deeper levels)
    #   topic: "opcua/+" → returns all topics at opcua/device level like "opcua/device1/sensor1"
    #   topic: "+" → returns all top-level topic categories
    # Requires an ArchiveGroup because topics are stored in the group's last value store
    browseTopics(
        # MQTT topic path with optional '+' single-level wildcard
        topic: String!
        # ArchiveGroup name containing the topics (required for data isolation)
        archiveGroup: String = "Default"
    ): [Topic!]!
    
    # Get broker node information and metrics for monitoring cluster health
    # Returns current metrics, session counts, and node status information
    broker(
        # Cluster node ID (optional - if omitted, returns current node)
        nodeId: String
    ): Broker

    # Get information about all broker nodes in the MonsterMQ cluster
    # Useful for cluster monitoring and load distribution analysis
    # Returns array of all active cluster nodes with their metrics
    brokers: [Broker!]!

    # Get MQTT client sessions across the cluster or from specific nodes
    # Sessions represent MQTT client connections with their state and subscriptions
    sessions(
        # Filter by specific cluster node (optional - if omitted, returns sessions from all nodes)
        nodeId: String,
        # Filter by session type: true=clean sessions, false=persistent sessions, null=all
        cleanSession: Boolean,
        # Filter by connection status: true=connected, false=disconnected, null=all
        connected: Boolean
    ): [Session!]!

    # Get detailed information about a specific MQTT client session
    # Includes metrics, subscriptions, and connection status
    session(
        # MQTT client ID to look up
        clientId: String!,
        # Node ID where session is located (optional - will be auto-discovered if omitted)
        nodeId: String
    ): Session

    # User Management - Get user accounts and their permissions
    # Returns authentication and authorization information for MQTT access control
    users(
        # Filter by specific username (optional - if omitted, returns all users)
        username: String
    ): [UserInfo!]!

    # ArchiveGroup Management - Get data archiving configurations
    # Shows how MQTT topics are organized and stored across different databases
    archiveGroups: [ArchiveGroupInfo!]!

    # Get detailed information about a specific ArchiveGroup
    # Includes topic filters, storage configuration, and connection status
    archiveGroup(
        # Name of the ArchiveGroup to retrieve
        name: String!
    ): ArchiveGroupInfo
}

type Mutation {
    # Authenticate with username/password to obtain a JWT token for API access
    # Required for accessing protected mutations (publishing, user management, etc.)
    # Returns null when user authentication is disabled in MonsterMQ configuration
    login(
        # Username for authentication
        username: String!,
        # Password for authentication
        password: String!
    ): LoginResult

    # Publish an MQTT message to a specific topic through the broker
    # Message will be distributed to all subscribers and optionally stored based on ArchiveGroup settings
    # Requires valid JWT token and publish permission for the topic
    publish(
        # Message details including topic, payload, QoS, and retention settings
        input: PublishInput!
    ): PublishResult!

    # Publish multiple MQTT messages in a single atomic operation
    # Useful for bulk data ingestion and reducing API call overhead
    # All messages must pass ACL checks or the entire batch will be rejected
    publishBatch(
        # Array of messages to publish simultaneously
        inputs: [PublishInput!]!
    ): [PublishResult!]!
}

# User Management Mutations - Grouped operations for user and ACL management
type UserManagementMutations {
    # Create a new user account with specified permissions and access rights
    # Sets up authentication credentials and initial ACL permissions
    # Requires admin JWT token for execution
    createUser(
        # User account details including username, password, and permission flags
        input: CreateUserInput!
    ): UserManagementResult!

    # Update an existing user account's permissions and settings
    # Can modify enabled status, subscription/publish rights, and admin privileges
    # Cannot change username or password (use setPassword for password changes)
    updateUser(
        # Updated user details (only specified fields will be changed)
        input: UpdateUserInput!
    ): UserManagementResult!

    # Permanently delete a user account and all associated ACL rules
    # This action cannot be undone - the user will immediately lose access
    # Active sessions for the user will be terminated
    deleteUser(
        # Username of the account to delete
        username: String!
    ): UserManagementResult!

    # Change the password for an existing user account
    # New password will be securely hashed before storage
    # User's existing sessions may need to re-authenticate
    setPassword(
        # Username and new password details
        input: SetPasswordInput!
    ): UserManagementResult!

    # Create a new ACL (Access Control List) rule for topic-level permissions
    # Rules define which topics a user can subscribe to or publish on
    # Higher priority rules override lower priority ones
    createAclRule(
        # ACL rule details including user, topic pattern, and permissions
        input: CreateAclRuleInput!
    ): UserManagementResult!

    # Update an existing ACL rule's permissions or topic pattern
    # Changes take effect immediately for new client connections
    # Existing subscriptions may be affected based on the changes
    updateAclRule(
        # Updated ACL rule details (ID required, other fields optional)
        input: UpdateAclRuleInput!
    ): UserManagementResult!

    # Delete an ACL rule permanently
    # Users may lose access to topics if this was their only permission rule
    # Active subscriptions using this rule may be terminated
    deleteAclRule(
        # Unique ID of the ACL rule to delete
        id: String!
    ): UserManagementResult!
}

# Extend Mutations for user management
extend type Mutation {
    # Remove queued messages from persistent sessions to free up memory
    # Useful for clearing message backlogs from disconnected clients
    # Can target a specific client or purge all queued messages cluster-wide
    purgeQueuedMessages(
        # Client ID to purge messages for (optional - if omitted, purges all clients)
        clientId: String
    ): PurgeResult!

    # Access user and ACL management operations
    # Returns a UserManagementMutations type that provides grouped mutation operations
    user: UserManagementMutations!
}

# Archive Group Mutations - Grouped operations for archive group management
type ArchiveGroupMutations {
    # Create a new ArchiveGroup to archive MQTT topics
    # ArchiveGroup configuration including topic filters and storage settings
    create(
        input: CreateArchiveGroupInput!
    ): ArchiveGroupResult!

    # Update an existing ArchiveGroup's configuration
    # Changes to topic filters take effect immediately
    # Database changes may require redeployment of the archive handlers
    update(
        # Updated ArchiveGroup settings (name required, other fields optional)
        input: UpdateArchiveGroupInput!
    ): ArchiveGroupResult!

    # Permanently delete an ArchiveGroup and stop archiving its topics
    # Existing archived data is preserved but no new data will be stored
    # Cannot delete the "Default" ArchiveGroup as it's required by the system
    delete(
        # Name of the ArchiveGroup to delete
        name: String!
    ): ArchiveGroupResult!

    # Enable a disabled ArchiveGroup to resume topic archiving
    # Restarts data collection for the group's topic filters
    # Useful for temporarily pausing and resuming data archiving
    enable(
        # Name of the ArchiveGroup to enable
        name: String!
    ): ArchiveGroupResult!

    # Disable an ArchiveGroup to pause topic archiving without deleting it
    # Stops new data collection but preserves existing archived data
    # Configuration remains intact for future re-enabling
    disable(
        # Name of the ArchiveGroup to disable
        name: String!
    ): ArchiveGroupResult!
}

# Extend Mutations for archive groups
extend type Mutation {
    # Access archive group management operations
    # Returns an ArchiveGroupMutations type that provides grouped mutation operations
    archiveGroup: ArchiveGroupMutations!
}

type Subscription {
    # Subscribe to real-time MQTT message updates for topics matching a filter
    # Creates a persistent GraphQL subscription that streams live data as messages are published
    # Uses WebSocket connection to deliver low-latency updates to dashboards and monitoring tools
    # Subscription will remain active until client disconnects or unsubscribes
    topicUpdates(
        # MQTT topic filter with wildcards: "sensor/+/temperature", "device/#", etc.
        # Supports both single-level (+) and multi-level (#) MQTT wildcards
        topicFilter: String!,
        # Data format for streamed message payloads
        format: DataFormat = JSON
    ): TopicUpdate!

    # Subscribe to real-time updates from multiple topic filters simultaneously
    # Efficient way to monitor different topic categories in a single subscription
    # All matching messages from any of the specified filters will be streamed
    # Useful for comprehensive dashboard monitoring across topic hierarchies
    multiTopicUpdates(
        # Array of MQTT topic filters to monitor simultaneously
        # Each filter supports MQTT wildcards independently
        topicFilters: [String!]!,
        # Data format for all streamed message payloads
        format: DataFormat = JSON
    ): TopicUpdate!
}

input PublishInput {
    # MQTT topic to publish the message to (no wildcards allowed for publishing)
    # Must follow MQTT topic naming conventions: use '/' as level separator
    topic: String!
    # Message payload content - format depends on the 'format' field
    # For JSON format: valid JSON string, for BINARY format: base64 encoded data
    payload: String!
    # Specifies how the payload should be interpreted and processed
    # JSON: payload is parsed as JSON, BINARY: payload is treated as base64 encoded binary data
    format: DataFormat = JSON
    # MQTT Quality of Service level: 0 (at most once), 1 (at least once), 2 (exactly once)
    # Higher QoS levels provide stronger delivery guarantees but with increased overhead
    qos: Int = 0
    # Whether this message should be retained by the broker for future subscribers
    # Retained messages are delivered to clients that subscribe after publication
    retained: Boolean = false
}

type PublishResult {
    success: Boolean!
    topic: String!
    timestamp: Long!
    error: String
}

type TopicValue {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
}

type Topic {
    # The topic name
    name: String!
    # The current value for this topic (null if no value exists)
    value(format: DataFormat = JSON): TopicValue
}

type RetainedMessage {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
}

type ArchivedMessage {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
    clientId: String
}

type TopicUpdate {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
    retained: Boolean!
    clientId: String
}

# User Management Types

type UserInfo {
    username: String!
    enabled: Boolean!
    canSubscribe: Boolean!
    canPublish: Boolean!
    isAdmin: Boolean!
    createdAt: String
    updatedAt: String
    aclRules: [AclRuleInfo!]!
}

type AclRuleInfo {
    id: String!
    username: String!
    topicPattern: String!
    canSubscribe: Boolean!
    canPublish: Boolean!
    priority: Int!
    createdAt: String
}

input CreateUserInput {
    username: String!
    password: String!
    enabled: Boolean = true
    canSubscribe: Boolean = true
    canPublish: Boolean = true
    isAdmin: Boolean = false
}

input UpdateUserInput {
    username: String!
    enabled: Boolean
    canSubscribe: Boolean
    canPublish: Boolean
    isAdmin: Boolean
}

input SetPasswordInput {
    username: String!
    password: String!
}

input CreateAclRuleInput {
    username: String!
    topicPattern: String!
    canSubscribe: Boolean = false
    canPublish: Boolean = false
    priority: Int = 0
}

input UpdateAclRuleInput {
    id: String!
    username: String
    topicPattern: String
    canSubscribe: Boolean
    canPublish: Boolean
    priority: Int
}

# ArchiveGroup Management Types
#
# ArchiveGroups are essential for organizing and managing MQTT data storage in MonsterMQ.
# Each ArchiveGroup defines:
# 1. Topic filters that determine which MQTT topics are stored
# 2. Storage backends (PostgreSQL, CrateDB, MongoDB, etc.) for both last values and historical data
# 3. Data retention policies and purge intervals
# 4. Whether to store only retained messages or all messages matching the filters
#
# Why ArchiveGroups are required for searchTopics and browseTopics:
# - MonsterMQ stores topic data in separate databases/collections per ArchiveGroup
# - Each group has its own "last value store" containing the most recent value for each topic
# - This isolation allows different topic categories to use different storage backends
# - Examples: IoT sensors in PostgreSQL, OPC UA data in CrateDB, logs in MongoDB
# - The "Default" ArchiveGroup is required and typically contains general MQTT topics
#
# Topic organization example:
# - Default ArchiveGroup: general/* topics → PostgreSQL
# - Industrial ArchiveGroup: opcua/*, modbus/* → CrateDB
# - Logging ArchiveGroup: logs/*, events/* → MongoDB

type NodeConnectionStatus {
    nodeId: String!
    # Connection status for different store components
    messageArchive: Boolean
    lastValueStore: Boolean
    # Error message if connection failed
    error: String
    # Timestamp when status was checked
    timestamp: Long!
}

type ArchiveGroupInfo {
    name: String!
    enabled: Boolean!
    deployed: Boolean!
    deploymentId: String
    topicFilter: [String!]!
    retainedOnly: Boolean!
    lastValType: MessageStoreType!
    archiveType: MessageArchiveType!
    payloadFormat: PayloadFormat!
    lastValRetention: String
    archiveRetention: String
    purgeInterval: String
    createdAt: String
    updatedAt: String
    # Database connection status from all nodes in the cluster
    connectionStatus: [NodeConnectionStatus!]!
    # Current metrics for this archive group (single most recent entry)
    metrics: [ArchiveGroupMetrics!]!
    # Historical metrics data for this archive group
    metricsHistory(
        # ISO 8601 timestamp for start of time range (e.g., "2024-01-15T10:00:00Z")
        from: String
        # ISO 8601 timestamp for end of time range (e.g., "2024-01-15T11:00:00Z")
        to: String
        # Alternative to from/to: get metrics from the last N minutes
        lastMinutes: Int
    ): [ArchiveGroupMetrics!]!
}

input CreateArchiveGroupInput {
    name: String!
    topicFilter: [String!]!
    retainedOnly: Boolean = false
    lastValType: MessageStoreType!
    archiveType: MessageArchiveType!
    payloadFormat: PayloadFormat = DEFAULT
    lastValRetention: String
    archiveRetention: String
    purgeInterval: String
}

input UpdateArchiveGroupInput {
    name: String!
    topicFilter: [String!]
    retainedOnly: Boolean
    lastValType: MessageStoreType
    archiveType: MessageArchiveType
    payloadFormat: PayloadFormat
    lastValRetention: String
    archiveRetention: String
    purgeInterval: String
}

type ArchiveGroupResult {
    success: Boolean!
    message: String
    archiveGroup: ArchiveGroupInfo
}

# Authentication Types
type LoginResult {
    success: Boolean!
    token: String
    message: String
    username: String
    isAdmin: Boolean!
}

type UserManagementResult {
    success: Boolean!
    message: String
    user: UserInfo
    aclRule: AclRuleInfo
}

type PurgeResult {
    success: Boolean!
    message: String
    deletedCount: Long!
}

# OPC UA Device Configuration Types

enum OpcUaPublishMode {
    SINGLE
    SEPARATE
}

# Certificate configuration for OPC UA connections with TLS/SSL security
type CertificateConfig {
    # Directory for storing certificates and keystores (relative to application root)
    securityDir: String!
    # Application name used in certificate subject (e.g., "MonsterMQ@localhost")
    applicationName: String!
    # Unique application URI for OPC UA client identification
    applicationUri: String!
    # Organization name for certificate subject
    organization: String!
    # Organizational unit for certificate subject  
    organizationalUnit: String!
    # Locality/city name for certificate subject
    localityName: String!
    # Two-letter country code for certificate subject (e.g., "US", "DE")
    countryCode: String!
    # Whether to automatically create self-signed certificates if none exist
    createSelfSigned: Boolean!
    # Password for protecting the keystore containing client certificates
    keystorePassword: String!
    # Whether to validate server certificates (enable for production security)
    validateServerCertificate: Boolean!
    # Auto-accept and save new server certificates to trust store (useful for initial setup)
    autoAcceptServerCertificates: Boolean!
}

# OPC UA address configuration for subscribing to OPC UA server nodes
type OpcUaAddress {
    # OPC UA node address - can be either NodeId or BrowsePath format:
    # NodeId examples: "ns=2;i=1234", "ns=2;s=MyDevice.Temperature", "ns=2;g=550e8400-e29b-41d4-a716-446655440000"
    # BrowsePath examples: "/Root/Objects/MyDevice/Temperature", "/Objects/2:MyDevice/2:Sensor1"
    # NodeId is more efficient, BrowsePath is more human-readable but requires browsing
    address: String!
    # MQTT topic where OPC UA values will be published
    topic: String!
    # How to publish OPC UA values: SINGLE (all in one message) or SEPARATE (individual messages)
    publishMode: OpcUaPublishMode!
    # Whether to remove the browse path from the topic name when using BrowsePath addresses
    removePath: Boolean!
}

type MonitoringParameters {
    bufferSize: Int!
    samplingInterval: Float!
    discardOldest: Boolean!
}

enum SecurityPolicy {
    None
    Basic256Sha256
    Basic256
    Basic128Rsa15
    Aes256_Sha256_RsaPss
    Aes128_Sha256_RsaOaep
}

type OpcUaConnectionConfig {
    endpointUrl: String!
    updateEndpointUrl: Boolean!
    securityPolicy: SecurityPolicy!
    username: String
    password: String
    subscriptionSamplingInterval: Float!
    keepAliveFailuresAllowed: Int!
    reconnectDelay: Long!
    connectionTimeout: Long!
    requestTimeout: Long!
    monitoringParameters: MonitoringParameters!
    addresses: [OpcUaAddress!]!
    # Certificate configuration for TLS/SSL connections and client authentication
    certificateConfig: CertificateConfig!
}

type OpcUaDevice {
    name: String!
    namespace: String!
    nodeId: String!
    backupNodeId: String
    config: OpcUaConnectionConfig!
    enabled: Boolean!
    createdAt: String!
    updatedAt: String!
    isOnCurrentNode: Boolean!
    # Current OPC UA device metrics (single most recent entry)
    metrics: [OpcUaDeviceMetrics!]!
    # Historical OPC UA device metrics (time-series)
    metricsHistory(
        from: String
        to: String
        lastMinutes: Int
        limit: Int = 100
    ): [OpcUaDeviceMetrics!]!
}

type ClusterNode {
    nodeId: String!
    isCurrent: Boolean!
}

type OpcUaDeviceResult {
    success: Boolean!
    device: OpcUaDevice
    errors: [String!]!
}

# OPC UA Server configuration that exposes MQTT topics as hierarchical OPC UA nodes
type OpcUaServer {
    # Unique server name across the cluster
    name: String!
    # MQTT namespace for internal communication
    namespace: String!
    # Target cluster node ("*" for all nodes, specific ID for single node)
    nodeId: String!
    # Whether the server is enabled
    enabled: Boolean!
    # OPC UA server port
    port: Int!
    # OPC UA server endpoint path
    path: String!
    # OPC UA namespace index
    namespaceIndex: Int!
    # OPC UA namespace URI
    namespaceUri: String!
    # MQTT topic to OPC UA node mappings
    addresses: [OpcUaServerAddress!]!
    # Security configuration
    security: OpcUaServerSecurity!
    # Buffer size for value updates
    bufferSize: Int!
    # Minimum update interval in milliseconds
    updateInterval: Long!
    # Server creation timestamp
    createdAt: String!
    # Server last update timestamp
    updatedAt: String!
    # Whether this server is running on the current node
    isOnCurrentNode: Boolean!
    # Current server status (if running on accessible node)
    status: OpcUaServerStatus
    # List trusted certificates for this server
    trustedCertificates: [OpcUaServerCertificate!]!
    # List untrusted (rejected) certificates for this server
    untrustedCertificates: [OpcUaServerCertificate!]!
}

# MQTT topic to OPC UA node mapping configuration
type OpcUaServerAddress {
    # MQTT topic pattern with wildcards (e.g., "factory/+/temperature")
    mqttTopic: String!
    # Optional human-readable display name for the OPC UA node
    displayName: String
    # Optional browse name (defaults to last topic segment)
    browseName: String
    # Optional description for the node
    description: String
    # Data type conversion strategy
    dataType: OpcUaServerDataType!
    # OPC UA node access level
    accessLevel: OpcUaServerAccessLevel!
    # Optional engineering unit (e.g., "°C", "bar")
    unit: String
}

# Data type conversion strategy between MQTT and OPC UA
enum OpcUaServerDataType {
    # ByteString - raw payload bytes
    BINARY
    # String - payload as UTF-8 text
    TEXT
    # Double - parse payload as number
    NUMERIC
    # Boolean - parse payload as true/false
    BOOLEAN
    # Custom JSON format: {"value": x, "timestamp": "iso", "status": int}
    JSON
}

# OPC UA node access level
enum OpcUaServerAccessLevel {
    # OPC UA clients can only read
    READ_ONLY
    # OPC UA clients can read and write (writes go back to MQTT)
    READ_WRITE
}

# Security configuration for OPC UA server
type OpcUaServerSecurity {
    # Path to keystore file (default: reuse MQTT server keystore)
    keystorePath: String!
    # Certificate alias in keystore
    certificateAlias: String!
    # Supported security policies
    securityPolicies: [String!]!
    # Allow anonymous access
    allowAnonymous: Boolean!
    # Require user authentication
    requireAuthentication: Boolean!
}

# Current status of an OPC UA Server instance
type OpcUaServerStatus {
    # Server name
    serverName: String!
    # Node ID where server is running
    nodeId: String!
    # Current status
    status: OpcUaServerStatusEnum!
    # Server port (if running)
    port: Int
    # Bound addresses (if running)
    boundAddresses: [String!]!
    # OPC UA endpoint URL (if running)
    endpointUrl: String
    # Number of active client connections
    activeConnections: Int!
    # Number of OPC UA nodes created
    nodeCount: Int!
    # Error message (if status is ERROR)
    error: String
    # Last status update timestamp
    lastUpdated: String!
}

# OPC UA Server status enumeration
enum OpcUaServerStatusEnum {
    STOPPED
    STARTING
    RUNNING
    ERROR
    STOPPING
}

# Represents a certificate file in the trust directories
type OpcUaServerCertificate {
    # Server name this certificate belongs to
    serverName: String!
    # Certificate fingerprint/hash for unique identification
    fingerprint: String!
    # Subject information from the certificate
    subject: String!
    # Issuer information
    issuer: String!
    # Certificate validity period
    validFrom: String!
    validTo: String!
    # Whether certificate is currently trusted or untrusted
    trusted: Boolean!
    # File path relative to the trusted/untrusted directory
    filePath: String!
    # When this certificate was first detected
    firstSeen: String!
}

# Result type for certificate operations
type CertificateManagementResult {
    success: Boolean!
    message: String
    affectedCertificates: [OpcUaServerCertificate!]!
}

# Simplified OPC UA Server information (used by mutations)
type OpcUaServerInfo {
    name: String!
    namespace: String!
    nodeId: String!
    enabled: Boolean!
    port: Int!
    path: String!
    namespaceIndex: Int!
    namespaceUri: String!
    addresses: [OpcUaServerAddress!]!
    security: OpcUaServerSecurityInfo!
    bufferSize: Int!
    updateInterval: Long!
    createdAt: String!
    updatedAt: String!
    isOnCurrentNode: Boolean!
    status: OpcUaServerStatus
}

# Simplified security information for OPC UA servers
type OpcUaServerSecurityInfo {
    keystorePath: String!
    certificateAlias: String!
    securityPolicies: [String!]!
    allowAnonymous: Boolean!
    requireAuthentication: Boolean!
}

# Result type for OPC UA Server operations
type OpcUaServerResult {
    success: Boolean!
    server: OpcUaServerInfo
    errors: [String!]!
}

# Result type for simplified OPC UA Server operations
type OpcUaServerOperationResult {
    success: Boolean!
    message: String
}

# Input for creating or updating an OPC UA Server
input OpcUaServerInput {
    # Unique server name across the cluster
    name: String!
    # MQTT namespace for internal communication (optional, defaults to "opcua/server/{name}")
    namespace: String
    # Target cluster node ("*" for all nodes, specific ID for single node)
    nodeId: String = "*"
    # Whether the server should be enabled
    enabled: Boolean = true
    # OPC UA server port
    port: Int = 4840
    # OPC UA server endpoint path
    path: String = "server"
    # OPC UA namespace index (must be >= 1)
    namespaceIndex: Int = 1
    # OPC UA namespace URI
    namespaceUri: String = "urn:MonsterMQ:OpcUaServer"
    # MQTT topic to OPC UA node mappings
    addresses: [OpcUaServerAddressInput!]!
    # Security configuration
    security: OpcUaServerSecurityInput
    # Buffer size for value updates
    bufferSize: Int = 1000
    # Minimum update interval in milliseconds
    updateInterval: Long = 100
}

# Input for MQTT topic to OPC UA node mapping
input OpcUaServerAddressInput {
    # MQTT topic pattern with wildcards (e.g., "factory/+/temperature")
    mqttTopic: String!
    # Optional human-readable display name for the OPC UA node
    displayName: String
    # Optional browse name (defaults to last topic segment)
    browseName: String
    # Optional description for the node
    description: String
    # Data type conversion strategy
    dataType: OpcUaServerDataType = TEXT
    # OPC UA node access level
    accessLevel: OpcUaServerAccessLevel = READ_ONLY
    # Optional engineering unit (e.g., "°C", "bar")
    unit: String
}

# Input for OPC UA server security configuration
input OpcUaServerSecurityInput {
    # Path to keystore file (default: reuse MQTT server keystore)
    keystorePath: String = "server-keystore.jks"
    # Keystore password
    keystorePassword: String = "password"
    # Certificate alias in keystore
    certificateAlias: String = "server-cert"
    # Supported security policies
    securityPolicies: [String!] = ["None", "Basic256Sha256"]
    # Allow anonymous access
    allowAnonymous: Boolean = true
    # Require user authentication
    requireAuthentication: Boolean = false
}

# Simplified input for creating OPC UA servers (matches web form)
input OpcUaServerConfigInput {
    # Unique server name across the cluster
    name: String!
    # MQTT namespace for internal communication
    namespace: String!
    # Target cluster node ("*" for all nodes, specific ID for single node)
    nodeId: String!
    # Whether the server should be enabled
    enabled: Boolean = true
    # OPC UA server port
    port: Int = 4840
    # OPC UA server endpoint path
    path: String = "monstermq"
    # OPC UA namespace URI
    namespaceUri: String
    # Minimum update interval in milliseconds
    updateInterval: Long = 1000
    # Buffer size for value updates
    bufferSize: Int = 1000
}

input MonitoringParametersInput {
    bufferSize: Int = 100
    samplingInterval: Float = 0.0
    discardOldest: Boolean = false
}

# Input type for certificate configuration settings
input CertificateConfigInput {
    # Directory for storing certificates and keystores (default: "security")
    securityDir: String = "security"
    # Application name for certificate subject (default: "MonsterMQ@localhost")
    applicationName: String = "MonsterMQ@localhost"
    # Application URI for OPC UA client identification (default: "urn:MonsterMQ:Client")
    applicationUri: String = "urn:MonsterMQ:Client"
    # Organization name for certificate subject (default: "MonsterMQ")
    organization: String = "MonsterMQ"
    # Organizational unit for certificate subject (default: "Client")
    organizationalUnit: String = "Client"
    # Locality/city name for certificate subject (default: "Unknown")
    localityName: String = "Unknown"
    # Two-letter country code (default: "XX")
    countryCode: String = "XX"
    # Whether to create self-signed certificates automatically (default: true)
    createSelfSigned: Boolean = true
    # Keystore password for certificate protection (default: "password")
    keystorePassword: String = "password"
    # Whether to validate server certificates (default: true for security)
    validateServerCertificate: Boolean = true
    # Auto-accept and save new server certificates (default: false, enable for initial setup)
    autoAcceptServerCertificates: Boolean = false
}

input OpcUaConnectionConfigInput {
    endpointUrl: String!
    updateEndpointUrl: Boolean = true
    securityPolicy: SecurityPolicy = None
    username: String
    password: String
    subscriptionSamplingInterval: Float = 0.0
    keepAliveFailuresAllowed: Int = 3
    reconnectDelay: Long = 5000
    connectionTimeout: Long = 10000
    requestTimeout: Long = 5000
    monitoringParameters: MonitoringParametersInput
    # Certificate configuration for TLS/SSL and client authentication
    certificateConfig: CertificateConfigInput
}

input OpcUaAddressInput {
    # OPC UA node address - supports two formats:
    # 1. NodeId (recommended for performance): "ns=2;i=1234", "ns=2;s=MyDevice.Temperature", "ns=2;g=UUID"
    # 2. BrowsePath (human-readable): "/Root/Objects/MyDevice/Temperature", "/Objects/2:MyDevice/2:Sensor1"
    address: String!
    # MQTT topic where OPC UA values will be published
    topic: String!
    # SINGLE: publish all subscribed values in one JSON object, SEPARATE: individual messages per value
    publishMode: OpcUaPublishMode = SEPARATE
    # For BrowsePath addresses: whether to remove the path prefix from generated topic names
    removePath: Boolean = true
}

input OpcUaDeviceInput {
    name: String!
    namespace: String!
    nodeId: String!
    backupNodeId: String
    config: OpcUaConnectionConfigInput!
    enabled: Boolean = true
}

# Extend existing Query type
extend type Query {
    # Get all OPC UA device configurations across the entire cluster
    # Returns devices from all cluster nodes, showing their assignment and status
    opcUaDevices: [OpcUaDevice!]!

    # Get a specific OPC UA device configuration by its unique name
    # Device names must be unique across the entire MonsterMQ cluster
    opcUaDevice(name: String!): OpcUaDevice

    # Get OPC UA devices assigned to a specific cluster node
    # Useful for monitoring device distribution and cluster load balancing
    opcUaDevicesByNode(nodeId: String!): [OpcUaDevice!]!

    # Get list of all available cluster nodes for device assignment
    # Shows which nodes are available for deploying OPC UA device connectors
    clusterNodes: [ClusterNode!]!

    # Get all OPC UA server configurations across the entire cluster
    # Returns servers from all cluster nodes, showing their assignment and status
    opcUaServers: [OpcUaServer!]!

    # Get a specific OPC UA server configuration by its unique name
    # Server names must be unique across the entire MonsterMQ cluster
    opcUaServer(name: String!): OpcUaServer

    # Get OPC UA servers assigned to a specific cluster node
    # Useful for monitoring server distribution and cluster load balancing
    opcUaServersByNode(nodeId: String!): [OpcUaServer!]!

    # Get certificates for a specific OPC UA server
    opcUaServerCertificates(
        serverName: String!,
        # Filter by trust status: true=trusted, false=untrusted, null=all
        trusted: Boolean
    ): [OpcUaServerCertificate!]!

    # Get all MQTT client configurations across the entire cluster
    # Returns clients from all cluster nodes, showing their assignment and connection status
    mqttClients: [MqttClient!]!

    # Get a specific MQTT client configuration by its unique name
    # Client names must be unique across the entire MonsterMQ cluster
    mqttClient(name: String!): MqttClient

    # Get MQTT clients assigned to a specific cluster node
    # Useful for monitoring client distribution and cluster load balancing
    mqttClientsByNode(nodeId: String!): [MqttClient!]!


    }

# OPC UA Device Mutations - Grouped operations for OPC UA device management
type OpcUaDeviceMutations {
    # Add a new OPC UA device configuration
    # Creates a new OPC UA device that connects to a remote OPC UA server and subscribes to node changes
    add(input: OpcUaDeviceInput!): OpcUaDeviceResult!

    # Update an existing OPC UA device configuration
    # Changes take effect immediately - the device connector will be redeployed with new settings
    # Useful for modifying connection parameters, security settings, or sampling intervals
    update(name: String!, input: OpcUaDeviceInput!): OpcUaDeviceResult!

    # Delete an OPC UA device configuration permanently
    # Stops the device connector and removes all configuration data
    # Returns true if deletion was successful, false if device was not found
    delete(name: String!): Boolean!

    # Enable or disable an OPC UA device without deleting its configuration
    # Disabled devices stop collecting data but retain their configuration
    # Useful for temporarily pausing data collection or troubleshooting
    toggle(name: String!, enabled: Boolean!): OpcUaDeviceResult!

    # Reassign an OPC UA device to a different cluster node
    # Moves the device connector from one node to another for load balancing
    # The device configuration remains unchanged, only the deployment location changes
    reassign(name: String!, nodeId: String!): OpcUaDeviceResult!

    # Add a new OPC UA address (node subscription) to an existing device
    # The address can be either a NodeId or BrowsePath - see OpcUaAddressInput for format details
    # New addresses will immediately start collecting data from the OPC UA server
    addAddress(deviceName: String!, input: OpcUaAddressInput!): OpcUaDeviceResult!

    # Remove an OPC UA address subscription from a device
    # Stops data collection for the specified address while keeping other addresses active
    # Use the exact address string that was used when adding the address
    deleteAddress(deviceName: String!, address: String!): OpcUaDeviceResult!
}

# Extend Mutations for OPC UA devices
extend type Mutation {
    # Access OPC UA device management operations
    # Returns an OpcUaDeviceMutations type that provides grouped mutation operations
    opcUaDevice: OpcUaDeviceMutations!
}

# OPC UA Server Mutations - Grouped operations for OPC UA server management
type OpcUaServerMutations {
    # Add a new OPC UA server configuration
    # Creates a new OPC UA server that exposes MQTT topics as OPC UA nodes with hierarchical structure
    add(input: OpcUaServerInput!): OpcUaServerResult!

    # Update an existing OPC UA server configuration
    # Changes will be applied immediately - server will be restarted if currently running
    update(name: String!, input: OpcUaServerInput!): OpcUaServerResult!

    # Enable or disable an OPC UA server
    # Controls whether the server should be running on the target cluster nodes
    toggle(name: String!, enabled: Boolean!): OpcUaServerResult!

    # Reassign an OPC UA server to different cluster node(s)
    # Moves the server from one node to another or changes multi-node deployment
    reassign(name: String!, nodeId: String!): OpcUaServerResult!

    # Create a new OPC UA server configuration (simplified form)
    # Creates a server using simplified configuration matching the web form
    create(config: OpcUaServerConfigInput!): OpcUaServerOperationResult!

    # Start an OPC UA server
    start(serverName: String!, nodeId: String): OpcUaServerOperationResult!

    # Stop an OPC UA server
    stop(serverName: String!, nodeId: String): OpcUaServerOperationResult!

    # Delete an OPC UA server instance
    delete(serverName: String!): OpcUaServerOperationResult!

    # Add an address mapping to an existing OPC UA Server
    # Adds a new MQTT topic to OPC UA node mapping to the server configuration
    addAddress(
        serverName: String!,
        address: OpcUaServerAddressInput!
    ): OpcUaServerOperationResult!

    # Remove an address mapping from an existing OPC UA Server
    # Removes a mapping by its MQTT topic pattern
    removeAddress(
        serverName: String!,
        mqttTopic: String!
    ): OpcUaServerOperationResult!

    # Trust one or more certificates (move from untrusted to trusted directory)
    trustCertificates(
        serverName: String!,
        # Certificate fingerprints to trust
        fingerprints: [String!]!
    ): CertificateManagementResult!

    # Delete certificates completely (from both trusted and untrusted directories)
    deleteCertificates(
        serverName: String!,
        fingerprints: [String!]!
    ): CertificateManagementResult!
}

# Extend Mutations for OPC UA servers
extend type Mutation {
    # Access OPC UA server management operations
    # Returns an OpcUaServerMutations type that provides grouped mutation operations
    opcUaServer: OpcUaServerMutations!
}

# MQTT Client Mutations - Grouped operations for MQTT client management
type MqttClientMutations {
    # Create a new MQTT client bridge to connect to a remote MQTT broker
    # Creates a client connector that will be deployed on the specified cluster node
    # The client can subscribe to remote topics or publish local topics to the remote broker
    create(input: MqttClientInput!): MqttClientResult!

    # Update an existing MQTT client configuration
    # Changes take effect immediately - the client connector will be redeployed with new settings
    # Useful for modifying connection parameters, credentials, or topic mappings
    update(name: String!, input: MqttClientInput!): MqttClientResult!

    # Delete an MQTT client configuration permanently
    # Stops the client connector and removes all configuration data
    # Returns true if deletion was successful, false if client was not found
    delete(name: String!): Boolean!

    # Start an MQTT client connection
    # Enables a previously stopped client and establishes connection to remote broker
    start(name: String!): MqttClientResult!

    # Stop an MQTT client connection
    # Disables the client and disconnects from remote broker while preserving configuration
    stop(name: String!): MqttClientResult!

    # Toggle MQTT client enabled state
    # Enable or disable an MQTT client without deleting its configuration
    toggle(name: String!, enabled: Boolean!): MqttClientResult!

    # Reassign an MQTT client to a different cluster node
    # Moves the client connector from one node to another for load balancing
    # The client configuration remains unchanged, only the deployment location changes
    reassign(name: String!, nodeId: String!): MqttClientResult!

    # Add a new address mapping to an existing MQTT client
    # Defines how topics are mapped between local and remote brokers (subscribe/publish)
    # New mappings will immediately start synchronizing data
    addAddress(deviceName: String!, input: MqttClientAddressInput!): MqttClientResult!

    # Remove an address mapping from an MQTT client
    # Stops data synchronization for the specified remote topic while keeping other mappings active
    deleteAddress(deviceName: String!, remoteTopic: String!): MqttClientResult!
}

# Extend Mutations for MQTT clients
extend type Mutation {
    # Access MQTT client management operations
    # Returns a MqttClientMutations type that provides grouped mutation operations
    mqttClient: MqttClientMutations!
}

# MQTT Client Configuration Types
#
# MQTT Clients allow MonsterMQ to act as a bridge between this broker and remote MQTT brokers.
# Each client establishes an outbound connection and can:
# 1. Subscribe to topics on the remote broker and republish them locally (SUBSCRIBE mode)
# 2. Subscribe to local topics and publish them to the remote broker (PUBLISH mode)
#
# Common use cases:
# - Bridging data between different MQTT infrastructures
# - Aggregating data from multiple remote brokers into a central MonsterMQ instance
# - Distributing data from MonsterMQ to multiple remote brokers
# - Creating hierarchical broker topologies for large-scale IoT deployments

# Connection mode for MQTT client address mappings
enum MqttClientMode {
    # Subscribe to remote broker topics and republish locally
    # Data flows: Remote Broker → MonsterMQ
    SUBSCRIBE
    # Subscribe to local topics and publish to remote broker
    # Data flows: MonsterMQ → Remote Broker
    PUBLISH
}

# MQTT Client address mapping configuration
# Defines how topics are mapped between local and remote brokers
type MqttClientAddress {
    # Connection mode: SUBSCRIBE (remote→local) or PUBLISH (local→remote)
    mode: String!
    # Topic pattern on the remote broker (supports MQTT wildcards: +, #)
    remoteTopic: String!
    # Topic pattern on the local broker (supports MQTT wildcards: +, #)
    localTopic: String!
    # Whether to remove the base path from topic names when mapping
    # Example: remoteTopic="sensor/#" with removePath=true maps "sensor/temp/1" to "temp/1"
    removePath: Boolean!
    # QoS level for MQTT messages (0=At most once, 1=At least once, 2=Exactly once)
    qos: Int
}

# MQTT Client connection configuration
type MqttClientConnectionConfig {
    # Connection protocol: "tcp", "tcps" (TLS), "ws" (WebSocket), "wss" (WebSocket Secure)
    protocol: String!
    # Remote broker hostname or IP address
    hostname: String!
    # Remote broker port (typically 1883 for TCP, 8883 for TLS)
    port: Int!
    # Username for authentication (optional)
    username: String
    # Client ID to use when connecting to remote broker
    clientId: String!
    # Whether to use a clean session (false = persistent session)
    cleanSession: Boolean!
    # Keep-alive interval in seconds
    keepAlive: Int!
    # Delay between reconnection attempts in milliseconds
    reconnectDelay: Long!
    # Connection timeout in milliseconds
    connectionTimeout: Long!
    # Topic mappings between local and remote brokers
    addresses: [MqttClientAddress!]!
    # Whether to enable message buffering when disconnected
    bufferEnabled: Boolean!
    # Maximum number of messages to buffer when disconnected (1-100000)
    bufferSize: Int!
    # Whether to persist the buffer to disk (false = memory only)
    persistBuffer: Boolean!
    # Whether to delete oldest messages when buffer is full (true = FIFO, false = reject new)
    deleteOldestMessages: Boolean!
}

# MQTT Client configuration
type MqttClient {
    # Unique client name across the cluster
    name: String!
    # MQTT namespace for internal communication
    namespace: String!
    # Cluster node ID where this client runs
    nodeId: String!
    # Connection and mapping configuration
    config: MqttClientConnectionConfig!
    # Whether this client is enabled and should connect
    enabled: Boolean!
    # Client creation timestamp
    createdAt: String!
    # Client last update timestamp
    updatedAt: String!
    # Whether this client is running on the current node
    isOnCurrentNode: Boolean!
    # Current metrics for this MQTT bridge client (single most recent entry)
    metrics: [MqttClientMetrics!]!
    # Historical metrics data for this MQTT bridge client
    metricsHistory(
        from: String
        to: String
        lastMinutes: Int
    ): [MqttClientMetrics!]!
}

# Result type for MQTT Client operations
type MqttClientResult {
    # Whether the operation succeeded
    success: Boolean!
    # The affected MQTT client (null if operation failed)
    client: MqttClient
    # Error messages if operation failed
    errors: [String!]!
}

# Input for creating or updating an MQTT client
input MqttClientInput {
    # Unique client name across the cluster
    name: String!
    # MQTT namespace for internal communication (e.g., "mqtt/client1")
    namespace: String!
    # Target cluster node (use "*" for automatic assignment)
    nodeId: String!
    # Whether the client should be enabled
    enabled: Boolean = true
    # Connection configuration
    config: MqttClientConnectionConfigInput!
}

# Input for MQTT client connection configuration
input MqttClientConnectionConfigInput {
    # Connection protocol: "tcp", "tcps", "ws", "wss"
    protocol: String = "tcp"
    # Remote broker hostname or IP address
    hostname: String!
    # Remote broker port
    port: Int = 1883
    # Username for authentication (optional)
    username: String
    # Password for authentication (optional)
    password: String
    # Client ID to use when connecting
    clientId: String = "monstermq-client"
    # Whether to use a clean session
    cleanSession: Boolean = true
    # Keep-alive interval in seconds
    keepAlive: Int = 60
    # Delay between reconnection attempts in milliseconds
    reconnectDelay: Long = 5000
    # Connection timeout in milliseconds
    connectionTimeout: Long = 30000
    # Whether to enable message buffering when disconnected (default: false)
    bufferEnabled: Boolean = false
    # Maximum number of messages to buffer when disconnected (default: 5000, max: 100000)
    bufferSize: Int = 5000
    # Whether to persist the buffer to disk (default: false = memory only)
    persistBuffer: Boolean = false
    # Whether to delete oldest messages when buffer is full (default: true = FIFO, false = reject new)
    deleteOldestMessages: Boolean = true
}

# Input for MQTT client address mapping
input MqttClientAddressInput {
    # Connection mode: "SUBSCRIBE" or "PUBLISH"
    mode: String!
    # Topic pattern on the remote broker
    remoteTopic: String!
    # Topic pattern on the local broker
    localTopic: String!
    # Whether to remove the base path from topic names
    removePath: Boolean = true
    # QoS level for MQTT messages (0, 1, or 2)
    qos: Int = 0
}

#############################################
# Kafka Client Bridge Configuration (NEW)  #
#############################################

"""
Kafka client bridge connects to an external Kafka cluster and republishes consumed
records as MQTT messages inside MonsterMQ. A single Kafka topic is consumed and each
record is polled periodically then published to MQTT.

Topic mapping strategy:
- The Kafka topic consumed is the device namespace
- For BINARY/TEXT formats: MQTT topic = record key (record dropped if key null)
- For DEFAULT/JSON formats: value encodes a BrokerMessage whose internal topicName is used
"""

enum KafkaPayloadFormat {
    # Internal encoded BrokerMessage format (default)
    DEFAULT
    # BrokerMessage serialized as JSON text
    JSON
    # Raw Kafka record value bytes -> published as binary payload (topic derived from key)
    BINARY
    # UTF-8 decoded Kafka record value string -> published as text payload (topic derived from key)
    TEXT
}

type KafkaClientConfig {
    # Comma separated host:port list
    bootstrapServers: String!
    # Kafka consumer group id
    groupId: String!
    # Payload transformation/serialization strategy
    payloadFormat: KafkaPayloadFormat!

    # Additional arbitrary Kafka consumer properties
    extraConsumerConfig: JSON
    # Poll interval in milliseconds
    pollIntervalMs: Long!
    # Max records per poll
    maxPollRecords: Int!
    # Reconnect delay to Kafka in milliseconds
    reconnectDelayMs: Long!
    # Optional prefix applied to all published MQTT topics.
    # Rules:
    # - Blank or whitespace disables prefixing
    # - Trailing slash automatically appended when missing
    # - Must not contain MQTT wildcards '+' or '#'
    # - Legacy keyTopicPrefix input still accepted for backward compatibility
    destinationTopicPrefix: String
    # NOTE: Kafka topic is now derived from the device namespace
}

type KafkaClientMetrics {
    messagesIn: Float!
    messagesOut: Float!
    timestamp: String!
}

type KafkaClient {
    name: String!
    namespace: String!
    nodeId: String!
    config: KafkaClientConfig!
    enabled: Boolean!
    createdAt: String!
    updatedAt: String!
    isOnCurrentNode: Boolean!
    metrics: [KafkaClientMetrics!]!
    metricsHistory(
        from: String
        to: String
        lastMinutes: Int
    ): [KafkaClientMetrics!]!
}

type KafkaClientResult {
    success: Boolean!
    client: KafkaClient
    errors: [String!]!
}

input KafkaClientConfigInput {
    bootstrapServers: String = "localhost:9092"
    groupId: String = "monstermq-subscriber"
    payloadFormat: KafkaPayloadFormat = DEFAULT
    extraConsumerConfig: JSON
    pollIntervalMs: Long = 500
    maxPollRecords: Int = 100
    reconnectDelayMs: Long = 5000
    # Optional prefix applied to all published MQTT topics (see KafkaClientConfig.destinationTopicPrefix)
    destinationTopicPrefix: String
    # NOTE: Kafka topic is now derived from the device namespace
}

input KafkaClientInput {
    name: String!
    namespace: String!
    nodeId: String!
    enabled: Boolean = true
    config: KafkaClientConfigInput!
}

# Extend Queries for Kafka clients
extend type Query {
    # Get all Kafka client bridge configurations across the entire cluster
    # Returns clients from all cluster nodes, showing their assignment and connection status
    # Kafka clients consume from external Kafka topics and republish as MQTT messages
    kafkaClients: [KafkaClient!]!

    # Get a specific Kafka client bridge configuration by its unique name
    # Client names must be unique across the entire MonsterMQ cluster
    kafkaClient(name: String!): KafkaClient

    # Get Kafka clients assigned to a specific cluster node
    # Useful for monitoring client distribution and cluster load balancing
    kafkaClientsByNode(nodeId: String!): [KafkaClient!]!
}

# Kafka Client Mutations - Grouped operations for Kafka client management
type KafkaClientMutations {
    # Create a new Kafka client bridge to consume from an external Kafka cluster
    # Creates a client connector that will be deployed on the specified cluster node
    # The client will automatically connect to Kafka, consume records, and republish as MQTT messages
    # Note: The Kafka topic to consume is derived from the device namespace
    create(input: KafkaClientInput!): KafkaClientResult!

    # Update an existing Kafka client configuration
    # Changes take effect immediately - the client connector will be redeployed with new settings
    # Useful for modifying bootstrap servers, consumer properties, or payload format
    update(name: String!, input: KafkaClientInput!): KafkaClientResult!

    # Delete a Kafka client configuration permanently
    # Stops the client connector and removes all configuration data
    # Returns true if deletion was successful, false if client was not found
    delete(name: String!): Boolean!

    # Start a Kafka client connection
    # Enables a previously stopped client and begins consuming from Kafka topic
    # Messages will be polled and republished as MQTT messages
    start(name: String!): KafkaClientResult!

    # Stop a Kafka client connection
    # Disables the client and stops consuming from Kafka while preserving configuration
    # Useful for temporarily pausing data ingestion or troubleshooting
    stop(name: String!): KafkaClientResult!

    # Toggle Kafka client enabled state
    # Enable or disable a Kafka client without deleting its configuration
    # Disabled clients stop consuming but retain their configuration and consumer group position
    toggle(name: String!, enabled: Boolean!): KafkaClientResult!

    # Reassign a Kafka client to a different cluster node
    # Moves the client connector from one node to another for load balancing
    # The client configuration remains unchanged, only the deployment location changes
    # Consumer group position is preserved across reassignments
    reassign(name: String!, nodeId: String!): KafkaClientResult!
}

# Extend Mutations for Kafka clients
extend type Mutation {
    # Access Kafka client management operations
    # Returns a KafkaClientMutations type that provides grouped mutation operations
    kafkaClient: KafkaClientMutations!
}

#############################################
# WinCC OA Client Configuration            #
#############################################

"""
WinCC OA Client connects to a WinCC OA GraphQL server and subscribes to datapoint changes
via WebSocket subscriptions. Each subscription uses the dpQueryConnectSingle GraphQL function
to monitor datapoint values and publishes them as MQTT messages.

Features:
- GraphQL authentication (username/password login or direct token)
- WebSocket subscriptions for real-time datapoint updates
- Configurable topic name transformation (remove system name, convert dots/underscores to slashes, regex)
- Multiple message formats: JSON_ISO (ISO timestamps), JSON_MS (epoch milliseconds), RAW_VALUE (plain values)
- Support for BLOB data types
- Topic name caching for performance
"""

enum WinCCOaMessageFormat {
    # JSON format with ISO 8601 timestamp: {"value": <value>, "time": "2025-10-06T18:03:05.984Z"}
    JSON_ISO
    # JSON format with epoch milliseconds: {"value": <value>, "time": 1728234185984}
    JSON_MS
    # Raw value only (as text or binary for BLOBs)
    RAW_VALUE
}

type WinCCOaTransformConfig {
    # Remove "System1:" prefix from datapoint names
    removeSystemName: Boolean!
    # Convert "." to "/" in datapoint names for MQTT topic hierarchy
    convertDotToSlash: Boolean!
    # Convert "_" to "/" in datapoint names for MQTT topic hierarchy
    convertUnderscoreToSlash: Boolean!
    # Optional regex pattern for additional name transformation
    regexPattern: String
    # Replacement string for regex pattern
    regexReplacement: String
}

type WinCCOaAddress {
    # GraphQL query for dpQueryConnectSingle
    # Example: "SELECT '_original.._value', '_original.._stime' FROM 'System1:Test_*'"
    query: String!
    # MQTT topic prefix for this subscription
    # Example: "test" will publish to "winccoa/plant1/test/..."
    topic: String!
    # Optional description for this address
    description: String!
    # Whether to request the answer row in dpQueryConnectSingle (initial values)
    answer: Boolean!
    # Whether to publish MQTT messages with retained flag
    retained: Boolean!
}

type WinCCOaConnectionConfig {
    # GraphQL endpoint URL (e.g., "http://winccoa:4000/graphql")
    graphqlEndpoint: String!
    # WebSocket endpoint URL (auto-derived from graphqlEndpoint if not specified)
    websocketEndpoint: String
    # Username for authentication (used with password for login mutation)
    username: String
    # Token for direct authentication (skips login if provided)
    token: String
    # Delay between reconnection attempts in milliseconds
    reconnectDelay: Long!
    # Connection timeout in milliseconds
    connectionTimeout: Long!
    # Message format for publishing datapoint values
    messageFormat: WinCCOaMessageFormat!
    # Topic name transformation configuration
    transformConfig: WinCCOaTransformConfig!
    # Configured datapoint subscriptions
    addresses: [WinCCOaAddress!]!
}

type WinCCOaClientMetrics {
    # Messages per second received from WinCC OA server (datapoint value changes)
    messagesIn: Float!
    # ISO 8601 timestamp when these metrics were captured
    timestamp: String!
}

type WinCCOaClient {
    # Unique client name across the cluster
    name: String!
    # MQTT namespace for internal communication
    namespace: String!
    # Cluster node ID where this client runs
    nodeId: String!
    # Connection and subscription configuration
    config: WinCCOaConnectionConfig!
    # Whether this client is enabled and should connect
    enabled: Boolean!
    # Client creation timestamp
    createdAt: String!
    # Client last update timestamp
    updatedAt: String!
    # Whether this client is running on the current node
    isOnCurrentNode: Boolean!
    # Current metrics for this WinCC OA Client client (single most recent entry)
    metrics: [WinCCOaClientMetrics!]!
    # Historical metrics data for this WinCC OA Client client
    metricsHistory(
        from: String
        to: String
        lastMinutes: Int
    ): [WinCCOaClientMetrics!]!
}

type WinCCOaClientResult {
    # Whether the operation succeeded
    success: Boolean!
    # The affected WinCC OA client (null if operation failed)
    client: WinCCOaClient
    # Error messages if operation failed
    errors: [String!]!
}

input WinCCOaTransformConfigInput {
    # Remove "System1:" prefix from datapoint names (default: true)
    removeSystemName: Boolean = true
    # Convert "." to "/" in datapoint names (default: true)
    convertDotToSlash: Boolean = true
    # Convert "_" to "/" in datapoint names (default: false)
    convertUnderscoreToSlash: Boolean = false
    # Optional regex pattern for additional transformation
    regexPattern: String
    # Replacement string for regex pattern
    regexReplacement: String
}

input WinCCOaConnectionConfigInput {
    # GraphQL endpoint URL
    graphqlEndpoint: String = "http://winccoa:4000/graphql"
    # WebSocket endpoint URL (optional, auto-derived if not specified)
    websocketEndpoint: String
    # Username for authentication (optional, omit for anonymous access)
    # If provided, password must also be provided
    username: String
    # Password for authentication (optional, omit for anonymous access)
    # If provided, username must also be provided
    password: String
    # Direct token for authentication (optional, skips login if provided)
    # If provided, username/password are ignored
    token: String
    # Delay between reconnection attempts in milliseconds
    reconnectDelay: Long = 5000
    # Connection timeout in milliseconds
    connectionTimeout: Long = 10000
    # Message format for publishing datapoint values
    messageFormat: WinCCOaMessageFormat = JSON_ISO
    # Topic name transformation configuration
    transformConfig: WinCCOaTransformConfigInput
    # Configured datapoint subscriptions
    addresses: [WinCCOaAddressInput!]
}

input WinCCOaAddressInput {
    # GraphQL query for dpQueryConnectSingle subscription
    query: String!
    # MQTT topic prefix for this subscription
    topic: String!
    # Optional description
    description: String
    # Whether to request the answer row in dpQueryConnectSingle (initial values)
    answer: Boolean = false
    # Whether to publish MQTT messages with retained flag
    retained: Boolean = false
}

input WinCCOaClientInput {
    # Unique client name across the cluster
    name: String!
    # MQTT namespace for internal communication (e.g., "winccoa/plant1")
    namespace: String!
    # Target cluster node (use "*" for automatic assignment)
    nodeId: String!
    # Whether the client should be enabled
    enabled: Boolean = true
    # Connection configuration
    config: WinCCOaConnectionConfigInput!
}

# Extend Queries for WinCC OA clients
extend type Query {
    # Get all WinCC OA client configurations across the entire cluster
    # Returns clients from all cluster nodes, showing their assignment and connection status
    winCCOaClients: [WinCCOaClient!]!

    # Get a specific WinCC OA client configuration by its unique name
    # Client names must be unique across the entire MonsterMQ cluster
    winCCOaClient(name: String!): WinCCOaClient

    # Get WinCC OA clients assigned to a specific cluster node
    # Useful for monitoring client distribution and cluster load balancing
    winCCOaClientsByNode(nodeId: String!): [WinCCOaClient!]!
}

# WinCC OA Device Mutations - Grouped operations for WinCC OA device management
type WinCCOaDeviceMutations {
    # Create a new WinCC OA client configuration to connect to a WinCC OA GraphQL server
    # Creates a client connector that will be deployed on the specified cluster node
    # The client will automatically connect and subscribe to configured datapoint queries
    create(input: WinCCOaClientInput!): WinCCOaClientResult!

    # Update an existing WinCC OA client configuration
    # Changes take effect immediately - the client connector will be redeployed with new settings
    # Useful for modifying connection parameters, credentials, or subscriptions
    update(name: String!, input: WinCCOaClientInput!): WinCCOaClientResult!

    # Delete a WinCC OA client configuration permanently
    # Stops the client connector and removes all configuration data
    # Returns true if deletion was successful, false if client was not found
    delete(name: String!): Boolean!

    # Start a WinCC OA client connection
    # Enables a previously stopped client and establishes connection to WinCC OA server
    start(name: String!): WinCCOaClientResult!

    # Stop a WinCC OA client connection
    # Disables the client and disconnects from WinCC OA server while preserving configuration
    stop(name: String!): WinCCOaClientResult!

    # Toggle WinCC OA client enabled state
    # Enable or disable a WinCC OA client without deleting its configuration
    toggle(name: String!, enabled: Boolean!): WinCCOaClientResult!

    # Reassign a WinCC OA client to a different cluster node
    # Moves the client connector from one node to another for load balancing
    # The client configuration remains unchanged, only the deployment location changes
    reassign(name: String!, nodeId: String!): WinCCOaClientResult!

    # Add a new subscription address to an existing WinCC OA client
    # Defines a GraphQL query subscription for monitoring datapoint changes
    # New subscriptions will immediately start receiving updates
    addAddress(deviceName: String!, input: WinCCOaAddressInput!): WinCCOaClientResult!

    # Remove a subscription address from a WinCC OA client
    # Stops monitoring the specified GraphQL query while keeping other subscriptions active
    deleteAddress(deviceName: String!, query: String!): WinCCOaClientResult!
}

# Extend Mutations for WinCC OA clients
extend type Mutation {
    # Access WinCC OA device management operations
    # Returns a WinCCOaDeviceMutations type that provides grouped mutation operations
    winCCOaDevice: WinCCOaDeviceMutations!
}

# ===================================
# WinCC Unified Client Configuration
# ===================================

# WinCC Unified address type enum
enum WinCCUaAddressType {
    # Subscribe to tag value changes
    TAG_VALUES
    # Subscribe to active alarms
    ACTIVE_ALARMS
}

# WinCC Unified message format options
enum WinCCUaMessageFormat {
    # JSON format with ISO 8601 timestamp: {"value": <value>, "time": "2024-01-01T12:00:00Z"}
    JSON_ISO
    # JSON format with milliseconds since epoch: {"value": <value>, "time": 1704110400000}
    JSON_MS
    # Raw value only (no timestamp)
    RAW_VALUE
}

# WinCC Unified address configuration for subscriptions
type WinCCUaAddress {
    # Address type (TAG_VALUES or ACTIVE_ALARMS)
    type: WinCCUaAddressType!
    # MQTT topic prefix for this subscription
    topic: String!
    # Optional description
    description: String
    # Whether to publish MQTT messages with retained flag
    retained: Boolean!
    # Name filters for TAG_VALUES type (e.g., ["HMI_*", "TANK_*"])
    nameFilters: [String!]
    # Whether to include quality information in TAG_VALUES data (default: false)
    includeQuality: Boolean
    # System names filter for ACTIVE_ALARMS type
    systemNames: [String!]
    # Filter string for ACTIVE_ALARMS type
    filterString: String
}

# Topic name transformation configuration
type WinCCUaTransformConfig {
    # Convert "." to "/" in tag names (default: true)
    convertDotToSlash: Boolean!
    # Convert "_" to "/" in tag names (default: false)
    convertUnderscoreToSlash: Boolean!
    # Optional regex pattern for additional transformation
    regexPattern: String
    # Replacement string for regex pattern
    regexReplacement: String
}

# WinCC Unified connection configuration
type WinCCUaConnectionConfig {
    # GraphQL endpoint URL (e.g., "http://winccua:4000/graphql")
    graphqlEndpoint: String!
    # WebSocket endpoint URL (defaults to graphqlEndpoint with ws:// protocol)
    websocketEndpoint: String
    # Username for authentication (required)
    username: String!
    # Password for authentication (required)
    password: String!
    # Delay between reconnection attempts in milliseconds
    reconnectDelay: Long!
    # Connection timeout in milliseconds
    connectionTimeout: Long!
    # Message format for publishing tag values
    messageFormat: WinCCUaMessageFormat!
    # Topic name transformation configuration
    transformConfig: WinCCUaTransformConfig!
    # Configured subscriptions (tags and alarms)
    addresses: [WinCCUaAddress!]!
}

type WinCCUaClientMetrics {
    # Messages per second received from WinCC Unified server (tag values and alarms)
    messagesIn: Float!
    # Connection status to WinCC Unified server
    connected: Boolean!
    # ISO 8601 timestamp when these metrics were captured
    timestamp: String!
}

type WinCCUaClient {
    # Unique client name across the cluster
    name: String!
    # MQTT namespace for internal communication
    namespace: String!
    # Cluster node ID where this client runs
    nodeId: String!
    # Connection and subscription configuration
    config: WinCCUaConnectionConfig!
    # Whether this client is enabled and should connect
    enabled: Boolean!
    # Client creation timestamp
    createdAt: String!
    # Client last update timestamp
    updatedAt: String!
    # Whether this client is running on the current node
    isOnCurrentNode: Boolean!
    # Current metrics for this WinCC Unified client (single most recent entry)
    metrics: [WinCCUaClientMetrics!]!
    # Historical metrics data for this WinCC Unified client
    metricsHistory(
        from: String
        to: String
        lastMinutes: Int
    ): [WinCCUaClientMetrics!]!
}

type WinCCUaClientResult {
    # Whether the operation succeeded
    success: Boolean!
    # The affected WinCC Unified client (null if operation failed)
    client: WinCCUaClient
    # Error messages if operation failed
    errors: [String!]!
}

input WinCCUaTransformConfigInput {
    # Convert "." to "/" in tag names (default: true)
    convertDotToSlash: Boolean = true
    # Convert "_" to "/" in tag names (default: false)
    convertUnderscoreToSlash: Boolean = false
    # Optional regex pattern for additional transformation
    regexPattern: String
    # Replacement string for regex pattern
    regexReplacement: String
}

input WinCCUaConnectionConfigInput {
    # GraphQL endpoint URL (e.g., "http://winccua:4000/graphql")
    graphqlEndpoint: String!
    # WebSocket endpoint URL (optional, defaults to graphqlEndpoint with ws:// protocol)
    websocketEndpoint: String
    # Username for authentication (required)
    username: String!
    # Password for authentication (required)
    password: String!
    # Delay between reconnection attempts in milliseconds
    reconnectDelay: Long = 5000
    # Connection timeout in milliseconds
    connectionTimeout: Long = 10000
    # Message format for publishing tag values
    messageFormat: String = "JSON_ISO"
    # Topic name transformation configuration
    transformConfig: WinCCUaTransformConfigInput
}

input WinCCUaAddressInput {
    # Address type (TAG_VALUES or ACTIVE_ALARMS)
    type: WinCCUaAddressType!
    # MQTT topic prefix for this subscription
    topic: String!
    # Optional description
    description: String
    # Whether to publish MQTT messages with retained flag
    retained: Boolean = false
    # Name filters for TAG_VALUES type (e.g., ["HMI_*", "TANK_*"])
    nameFilters: [String!]
    # Whether to include quality information in TAG_VALUES data (default: false)
    includeQuality: Boolean = false
    # System names filter for ACTIVE_ALARMS type
    systemNames: [String!]
    # Filter string for ACTIVE_ALARMS type
    filterString: String
}

input WinCCUaClientInput {
    # Unique client name across the cluster
    name: String!
    # MQTT namespace for internal communication (e.g., "winccua/plant1")
    namespace: String!
    # Target cluster node (use "*" for automatic assignment)
    nodeId: String!
    # Whether the client should be enabled
    enabled: Boolean = true
    # Connection configuration
    config: WinCCUaConnectionConfigInput!
}

# Extend Queries for WinCC Unified clients
extend type Query {
    # Get all WinCC Unified client configurations across the entire cluster
    # Returns clients from all cluster nodes, showing their assignment and connection status
    winCCUaClients: [WinCCUaClient!]!

    # Get a specific WinCC Unified client configuration by its unique name
    # Client names must be unique across the entire MonsterMQ cluster
    winCCUaClient(name: String!): WinCCUaClient

    # Get WinCC Unified clients assigned to a specific cluster node
    # Useful for monitoring client distribution and cluster load balancing
    winCCUaClientsByNode(nodeId: String!): [WinCCUaClient!]!
}

# WinCC Unified Device Mutations - Grouped operations for WinCC Unified device management
type WinCCUaDeviceMutations {
    # Create a new WinCC Unified client configuration to connect to a WinCC Unified GraphQL server
    # Creates a client connector that will be deployed on the specified cluster node
    # The client will automatically connect, authenticate, and subscribe to configured tags/alarms
    create(input: WinCCUaClientInput!): WinCCUaClientResult!

    # Update an existing WinCC Unified client configuration
    # Changes take effect immediately - the client connector will be redeployed with new settings
    # Useful for modifying connection parameters, credentials, or subscriptions
    update(name: String!, input: WinCCUaClientInput!): WinCCUaClientResult!

    # Delete a WinCC Unified client configuration permanently
    # Stops the client connector and removes all configuration data
    # Returns true if deletion was successful, false if client was not found
    delete(name: String!): Boolean!

    # Start a WinCC Unified client connection
    # Enables a previously stopped client and establishes connection to WinCC Unified server
    start(name: String!): WinCCUaClientResult!

    # Stop a WinCC Unified client connection
    # Disables the client and disconnects from WinCC Unified server while preserving configuration
    stop(name: String!): WinCCUaClientResult!

    # Toggle WinCC Unified client enabled state
    # Enable or disable a WinCC Unified client without deleting its configuration
    toggle(name: String!, enabled: Boolean!): WinCCUaClientResult!

    # Reassign a WinCC Unified client to a different cluster node
    # Moves the client connector from one node to another for load balancing
    # The client configuration remains unchanged, only the deployment location changes
    reassign(name: String!, nodeId: String!): WinCCUaClientResult!

    # Add a new subscription address to an existing WinCC Unified client
    # Can be either TAG_VALUES (requires nameFilters) or ACTIVE_ALARMS (optional filters)
    # New subscriptions will immediately start receiving updates
    addAddress(deviceName: String!, input: WinCCUaAddressInput!): WinCCUaClientResult!

    # Remove a subscription address from a WinCC Unified client
    # Stops monitoring the specified topic while keeping other subscriptions active
    deleteAddress(deviceName: String!, topic: String!): WinCCUaClientResult!
}

# Extend Mutations for WinCC Unified clients
extend type Mutation {
    # Access WinCC Unified device management operations
    # Returns a WinCCUaDeviceMutations type that provides grouped mutation operations
    winCCUaDevice: WinCCUaDeviceMutations!
}
