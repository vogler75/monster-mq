scalar Long
scalar JSON

enum DataFormat {
    JSON
    BINARY
}

# Metrics for the broker
type BrokerMetrics {
    # Total messages received from clients on this node
    messagesIn: Long!
    # Total messages sent to clients on this node
    messagesOut: Long!
    # Number of sessions on this node
    nodeSessionCount: Int!
    # Total number of sessions in the cluster
    clusterSessionCount: Int!
    # Total number of queued messages in the cluster
    queuedMessagesCount: Long!
}

# Represents a broker node in the cluster
type Broker {
    # The ID of the node
    nodeId: String!
    # Metrics for this broker node
    metrics: BrokerMetrics!
}

# Represents a client session
type Session {
    # The client ID
    clientId: String!
    # The ID of the node this session is connected to
    nodeId: String!
    # The session's metrics
    metrics: SessionMetrics!
    # The subscriptions for this session
    subscriptions: [MqttSubscription!]!
    # Is the session clean
    cleanSession: Boolean!
    # The session expiry interval
    sessionExpiryInterval: Long!
    # The client's address
    clientAddress: String
    # Whether the client is currently connected
    connected: Boolean!
    # Number of queued messages for this session
    queuedMessageCount: Long!
}

# Metrics for a single session
type SessionMetrics {
    # Messages received from this client
    messagesIn: Long!
    # Messages sent to this client
    messagesOut: Long!
}

# Represents an MQTT subscription
type MqttSubscription {
    # The topic filter
    topicFilter: String!
    # The Quality of Service level
    qos: Int!
}

type Query {
    # Get current value of a topic from LastValueStore
    currentValue(topic: String!, format: DataFormat = JSON, archiveGroup: String = "Default"): TopicValue
    
    # Get current values matching a topic filter
    currentValues(topicFilter: String!, format: DataFormat = JSON, limit: Int = 100, archiveGroup: String = "Default"): [TopicValue!]!
    
    # Get retained message for a specific topic
    retainedMessage(topic: String!, format: DataFormat = JSON): RetainedMessage
    
    # Get all retained messages matching a filter
    retainedMessages(topicFilter: String, format: DataFormat = JSON, limit: Int = 100): [RetainedMessage!]!
    
    # Query historical messages from archive
    archivedMessages(
        topicFilter: String!
        startTime: String
        endTime: String
        format: DataFormat = JSON
        limit: Int = 100
        archiveGroup: String = "Default"
    ): [ArchivedMessage!]!
    
    # Search for topics by name pattern
    searchTopics(
        pattern: String!
        limit: Int = 100
        archiveGroup: String = "Default"
    ): [String!]!
    
    # Get a specific broker by its node ID. If nodeId is omitted, returns the current node.
    broker(nodeId: String): Broker
    # Get all brokers in the cluster
    brokers: [Broker!]!
    # Get active sessions. If nodeId is omitted, returns sessions from all nodes.
    sessions(nodeId: String, cleanSession: Boolean, connected: Boolean): [Session!]!
    # Get a specific session by client ID. If nodeId is omitted, it will be looked up.
    session(clientId: String!, nodeId: String): Session

    # User Management
    users(username: String): [UserInfo!]!
}

type Mutation {
    # Authentication (no token required)
    login(username: String!, password: String!): LoginResult!
    
    # Publish a message to a topic (requires token + ACL check)
    publish(input: PublishInput!): PublishResult!
    
    # Publish multiple messages (requires token + ACL check)
    publishBatch(inputs: [PublishInput!]!): [PublishResult!]!
    
    # User Management (requires admin token)
    createUser(input: CreateUserInput!): UserManagementResult!
    updateUser(input: UpdateUserInput!): UserManagementResult!
    deleteUser(username: String!): UserManagementResult!
    setPassword(input: SetPasswordInput!): UserManagementResult!
    
    # ACL Rule Management (requires admin token)
    createAclRule(input: CreateAclRuleInput!): UserManagementResult!
    updateAclRule(input: UpdateAclRuleInput!): UserManagementResult!
    deleteAclRule(id: String!): UserManagementResult!

    # Queued Messages Management (requires admin token)
    purgeQueuedMessages(clientId: String): PurgeResult!
}

type Subscription {
    # Subscribe to real-time topic updates
    topicUpdates(topicFilter: String!, format: DataFormat = JSON): TopicUpdate!
    
    # Subscribe to multiple topic filters
    multiTopicUpdates(topicFilters: [String!]!, format: DataFormat = JSON): TopicUpdate!
}

input PublishInput {
    topic: String!
    payload: String!
    format: DataFormat = JSON
    qos: Int = 0
    retained: Boolean = false
}

type PublishResult {
    success: Boolean!
    topic: String!
    timestamp: Long!
    error: String
}

type TopicValue {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
}

type RetainedMessage {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
}

type ArchivedMessage {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
    clientId: String
}

type TopicUpdate {
    topic: String!
    payload: String!
    format: DataFormat!
    timestamp: Long!
    qos: Int!
    retained: Boolean!
    clientId: String
}

# User Management Types

type UserInfo {
    username: String!
    enabled: Boolean!
    canSubscribe: Boolean!
    canPublish: Boolean!
    isAdmin: Boolean!
    createdAt: String
    updatedAt: String
    aclRules: [AclRuleInfo!]!
}

type AclRuleInfo {
    id: String!
    username: String!
    topicPattern: String!
    canSubscribe: Boolean!
    canPublish: Boolean!
    priority: Int!
    createdAt: String
}

input CreateUserInput {
    username: String!
    password: String!
    enabled: Boolean = true
    canSubscribe: Boolean = true
    canPublish: Boolean = true
    isAdmin: Boolean = false
}

input UpdateUserInput {
    username: String!
    enabled: Boolean
    canSubscribe: Boolean
    canPublish: Boolean
    isAdmin: Boolean
}

input SetPasswordInput {
    username: String!
    password: String!
}

input CreateAclRuleInput {
    username: String!
    topicPattern: String!
    canSubscribe: Boolean = false
    canPublish: Boolean = false
    priority: Int = 0
}

input UpdateAclRuleInput {
    id: String!
    username: String
    topicPattern: String
    canSubscribe: Boolean
    canPublish: Boolean
    priority: Int
}

# Authentication Types
type LoginResult {
    success: Boolean!
    token: String
    message: String
    username: String
    isAdmin: Boolean!
}

type UserManagementResult {
    success: Boolean!
    message: String
    user: UserInfo
    aclRule: AclRuleInfo
}

type PurgeResult {
    success: Boolean!
    message: String
    deletedCount: Long!
}